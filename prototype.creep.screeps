var util = require('util');

Creep.prototype.add_task = function(obj) {
    if(!this.memory.task_queue) {
        this.memory.task_queue = [];
    }
    this.memory.task_queue.unshift(obj);
};

Creep.prototype.pop_task = function() {
    if(this.memory.task_queue) {
        this.memory.task_queue.shift();
        if(this.memory.task_queue.length == 0) {
            delete this.memory.task_queue;
        }
    }
};

Creep.prototype.has_task_in_queue = function(ttype) {
    var tq = [];
    if(this.memory.task_queue) {
        tq = this.memory.task_queue;
    }
    for(var i in tq) {
        var task = tq[i];
        if(ttype == task.type) {
            return task;
        }
    }
    return null;
};

Creep.prototype.renew_cost = function() {
    return floor(600 / this.body.length);
};

Creep.prototype.body_cost = function() {
    var body_list = [];
    this.body.forEach(function(obj) {
        body_list.push(obj.type);
    });
    return util.body_cost(body_list);
};

Creep.prototype.body_part_count = function(btype) {
    var sum = 0;
    this.body.forEach(function(obj) {
        if(obj.type == btype)
            sum++;
    });
    return sum;
};

Creep.prototype.maintain_cost = function() {
    var has_claim = _.includes(this.body, CLAIM);
    // claim creeps cannot be renewed.
    if(has_claim) {
        return 0;
    }
    return this.body_cost() / CREEP_LIFE_TIME;
};

Creep.prototype.is_full = function() {
    var total = _.sum(this.carry);
    return total == this.carryCapacity;
};

Creep.prototype.find_support = function() {
    var closest_spawn = this.pos.findClosestByPath(Game.spawns);
    if(closest_spawn) {
        this.deregister_support();
        closest_spawn.support_creep(this);
    }
};

Creep.prototype.deregister_support = function() {
    var spawn = Game.spawns[this.memory.support];
    if(spawn)
        spawn.unsupport_creep(this);
}

module.exports = {};
