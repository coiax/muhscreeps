var util = require('util');


_.extend(Creep.prototype, require('mixin.log'));
_.extend(Creep.prototype, require('mixin.task_stack'));

Creep.prototype.get_memory = function() {
    return this.memory;
}

Creep.prototype.wants_renew = function() {
    if(this.ticksToLive < 100 && this.memory.autorenew &&
        !this.has_task_in_queue("renew")) {
        return true;
    } else {
        return false;
    }
};

Creep.prototype.renew_cost = function() {
    return floor(600 / this.body.length);
};

Creep.prototype.body_cost = function() {
    var body_list = [];
    this.body.forEach(function(obj) {
        body_list.push(obj.type);
    });
    return util.body_cost(body_list);
};

Creep.prototype.body_part_count = function(btype, ignore_injured) {
    var sum = 0;
    this.body.forEach(function(obj) {
        if((obj.type == btype) && (!ignore_injured || obj.hits == 100))
            sum++;
    });
    return sum;
};

Creep.prototype.maintain_cost = function() {
    var has_claim = _.includes(this.body, CLAIM);
    // claim creeps cannot be renewed.
    if(has_claim) {
        return 0;
    }
    return this.body_cost() / CREEP_LIFE_TIME;
};

Creep.prototype.is_full = function() {
    var total = _.sum(this.carry);
    return total == this.carryCapacity;
};

Creep.prototype.is_empty = function() {
    var total = _.sum(this.carry);
    return total == 0;
};

Creep.prototype.find_support = function() {
    var closest_spawn = this.pos.findClosestByPath(Game.spawns);
    if(closest_spawn) {
        this.deregister_support();
        closest_spawn.support_creep(this);
    }
};

Creep.prototype.deregister_support = function() {
    var spawn = Game.spawns[this.memory.support];
    if(spawn)
        spawn.unsupport_creep(this);
}

Creep.prototype.set_support = function(spawn) {
    if(this.memory.support == spawn.name) {
        return null;
    } else {
        this.deregister_support();
        this.memory.support = spawn.name;
    }
}
