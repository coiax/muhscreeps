var cpu_tracker = require('cpu_tracker');
var util = require('util');

var task_functions = {
    harvest : function(task, creep) {
        if(creep.carryCapacity == creep.carry.energy) {
            return {outcome: "didnothing"};
        }
        var selected = Game.getObjectById(task.selected_source_id);
        if(!selected) {
            selected = creep.pos.findClosestByRange(FIND_SOURCES, {
                filter: function(src) {
                    return src.is_harvestable(creep);
            }});
            if(selected) {
                task.selected_source_id = selected.id;
            }
        }
        if(!selected) {
            creep.say("!sr?:(");
            if(!task.no_resupply) {
                return {outcome: "newtask", task: {type: "resupply"}};
            } else {
                return {outcome: "didnothing"};
            }
        }
        if(selected.energy == 0) {
            task.selected_source_id = null;
            return {outcome: "rerun"};
        }
        var rv = creep.harvest(selected);
        if(rv == ERR_NOT_IN_RANGE) {
            if(selected.is_harvestable(creep)) {
                creep.moveTo(selected);
                return {outcome: "continue"};
            } else {
                task.selected_source_id = null;
                return {outcome: "rerun"};
            }
        }
        if(creep.carryCapacity == creep.carry.energy) {
            return {outcome: "done"};
        } else {
            return {outcome: "continue"};
        }
    },
    construct : function(task, creep) {
        var resupply = task.resupply;
        var target = Game.getObjectById(task.target_id);
        if(!target) {
            creep.say("cs ?!?");
            return {outcome: "didnothing"};
        }
        if(creep.carry.energy == 0) {
            if(resupply) {
                return {outcome: "newtask", task: {type: resupply}};
            } else {
                return {outcome: "didnothing"};
            }
        }
        var rv;
        if(typeof target.progress == 'undefined') {
            if(target.hits == target.hitsMax) {
                return {outcome: "didnothing"};
            }
            rv = creep.repair(target);
        } else {
            // autorepair can intefere with our construction
            creep.cancelOrder("repair");
            rv = creep.build(target);
        }
        if(rv == ERR_NOT_IN_RANGE) {
            creep.moveTo(target);
        }
        return {outcome: "continue"};
    },
    resupply : function(task, creep) {
        var remaining_capacity = creep.carryCapacity - _.sum(creep.carry);
        if(creep.is_full()) {
            return {outcome: "didnothing"};
        }
        var gas_station = Game.getObjectById(task.gas_station_id);
        if(!gas_station) {
            var stypes = [STRUCTURE_CONTAINER, STRUCTURE_STORAGE];
            var possible_stations = creep.room.find(FIND_STRUCTURES, {
                filter: function(st) {
                    return st.is_type(stypes) && st.store[RESOURCE_ENERGY];
            }});
            var energies = creep.room.find(FIND_DROPPED_ENERGY);
            possible_stations = possible_stations.concat(energies);
            if(possible_stations.length) {
                gas_station = creep.pos.findClosestByRange(possible_stations);
                if(gas_station.structureType) {
                    task.gas_station_id = gas_station.id;
                } else {
                    var task = {type: "pickup", target_id: gas_station.id};
                    return {outcome: "newtask", task: task};
                }
            }
        }
        if(!gas_station) {
            var task = {type: "harvest", timeout: 30, no_resupply: true}
            return {outcome: "newtask", task: task}
        }
        var rc = creep.withdraw(gas_station, RESOURCE_ENERGY);
        if(rc == ERR_NOT_IN_RANGE) {
            creep.moveTo(gas_station);
            return {outcome: "continue"};
        } else if(rc == ERR_NOT_ENOUGH_RESOURCES) {
            task.gas_station_id = null
            return {outcome: "continue"};
        } else if(rc != OK) {
            creep.say("rs!" + rc);
            return {outcome: "continue"};
        } else {
            return {outcome: "done"};
        }
    },
    renew : function(task, creep) {
        if(creep.ticksToLive >= 1400) {
            return {outcome: "done"};
        }
        var spawn = Game.getObjectById(task.spawn_id);
        if(!spawn) {
            var spawns = [];
            for(var i in Game.spawns)
                spawns.push(Game.spawns[i]);
            spawn = creep.pos.findClosestByRange(spawns);
            if(spawn)
                task.spawn_id = spawn.id
        }
        if(!spawn) {
            creep.say("SPN?!?");
            return {outcome: "done"};
        }
        var rc = spawn.renewCreep(creep)
        creep.transfer(spawn, RESOURCE_ENERGY);
        if(rc == ERR_NOT_IN_RANGE) {
            creep.moveTo(spawn)
            return {outcome: "continue"};
        } else if((rc == ERR_FULL) || (rc == ERR_NOT_ENOUGH_ENERGY)) {
            return {outcome: "done"};
        }
        return {outcome: "continue"};
    },
    transfer_energy : function(task, creep) {
        // Deprecated.
        var task = {type: "transfer_to", target_id: task.target_id};
        return {outcome: "replace", task: task};
    },
    transfer_to : function(task, creep) {
        // Low level task; creep to navigate to target or destination
        // (once in destination room, look for a suitable structure, if
        // none found, choose the floor), and then transfer as much as
        // possible of the resource type
        var target = Game.getObjectById(task.target_id);
        var destination = util.memoryPosition(task.destination_pos);
        var resource_type = task.resource_type || RESOURCE_ENERGY;
        var amount = task.amount;

        if(!target && !destination)
            return {outcome: "didnothing"};

        if(typeof amount != 'undefined') {
            amount = max(creep.carry[resource_type], amount);
            task.amount = amount;
        }

        if(!target) {
            if(destination.roomName == creep.room.name) {
                var look = destination.look(LOOK_STRUCTURES);
                for(var i in look) {
                    var st = look[i];
                    var rc = creep.transfer(st, resource_type, amount);
                    if(rc == ERR_INVALID_TARGET) {
                        continue;
                    } else {
                        target = st;
                        task.target_id = target.id;
                        break;
                    }
                }
                if(!target)
                    return {outcome: "didnothing"};
            } else {
                creep.moveTo(destination);
                return {outcome: "continue"};
            }
        }
        task.destination_pos = target.pos;
        var rc = creep.transfer(target, resource_type, amount);
        switch(rc) {
            case ERR_NOT_OWNER:
            case ERR_BUSY:
            case ERR_NOT_ENOUGH_RESOURCES:
            case ERR_INVALID_ARGS:
                throw "transfer_to: transfer rc " + rc;
            case ERR_INVALID_TARGET:
            case ERR_FULL:
                return {outcome: "didnothing"};
                break;
            case ERR_NOT_IN_RANGE:
                creep.moveTo(target);
                return {outcome: "continue"};
            case OK:
                return {outcome: "done"};
            default:
                throw "Unrecognised rc " + rc;
        }
    },
    tower_target : function(task, tower) {
        target = Game.getObjectById(task.target_id);
        mode = task.mode;
        // The task timing out is done by the task manager.
        if(!mode || !target || tower.energy < TOWER_ENERGY_COST)
            return {outcome: "didnothing"};
        var rc;
        switch(mode) {
            case "heal":
                if(target.hits == target.hitsMax) {
                    return {outcome: "didnothing"};
                }
                rc = tower.heal(target);
                break;
            case "repair":
                if(target.hits == target.hitsMax) {
                    return {outcome: "didnothing"};
                }
                rc = tower.repair(target);
                break;
            case "attack":
                rc = tower.attack(target);
                break;
        }
        switch(rc) {
            case ERR_INVALID_TARGET:
            case ERR_RCL_NOT_ENOUGH:
                return {outcome: "didnothing"};
            case OK:
            case ERR_NOT_ENOUGH_RESOURCES:
                return {outcome: "continue"};
        }
    },
    dismantle : function(task, creep) {
        var target = Game.getObjectById(task.target_id);
        if(!target) {
            return {outcome: "didnothing"};
        }
        if(creep.carry.energy == creep.carryCapacity) {
            var task = {type: "deposit"}
            return {outcome: "newtask", task: task}
        }
        var rc = creep.dismantle(target);
        switch(rc) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(target);
                return {outcome: "continue"};
            case OK:
                return {outcome: "done"};
            default:
                return {outcome: "didnothing"};
        }
    },
    leave_location : function(task, creep) {
        var pos = util.memoryPosition(task.pos);
        if(creep.pos.isEqualTo(pos)) {
            creep.say("Aaaaaa!");
            creep.move(Math.floor((Math.random() * 8) + 1));
            return {outcome: "done"};
        } else {
            return {outcome: "didnothing"};
        }
    },
    move_to: function(task, creep) {
        var target = Game.getObjectById(task.target_id);
        var destination;
        if(target) {
            destination = target.pos;
        } else {
            destination = util.memoryPosition(task.destination_pos);
        }
        if(!destination) {
            return {outcome: "didnothing"};
        }
        if(creep.pos.isEqualTo(destination)) {
            return {outcome: "didnothing"};
        }
        var rc = creep.moveTo(destination);
        if(rc == ERR_NO_PATH) {
            return {outcome: "didnothing"};
        } else {
            return {outcome: "continue"};
        }
    },
    suicide: function(task, creep) {
        creep.suicide();
        return {outcome: "done"};
    },
    recycle: function(task, creep) {
        var spawn = Game.getObjectById(task.spawn_id);
        if(!spawn) {
            var spawns = [];
            for(var name in Game.spawns) {
                spawns.push(Game.spawns[name]);
            }
            spawn = creep.pos.findClosestByPath(spawns);
            if(spawn)
                task.spawn_id = spawn.id;
        }
        if(!spawn) {
            creep.suicide();
            return {outcome: "done"};
        }
        var rc = spawn.recycleCreep(creep);
        if(rc == ERR_NOT_IN_RANGE) {
            creep.moveTo(spawn);
            return {outcome: "continue"};
        } else {
            return {outcome: "done"};
        }
    },
    pickup : function(task, creep) {
        if(creep.is_full()) {
            return {outcome: "didnothing"};
        }
        var target = Game.getObjectById(task.target_id);
        if(!target) {
            return {outcome: "didnothing"};
        }
        var rc = creep.pickup(target);
        if(rc == ERR_NOT_IN_RANGE) {
            creep.moveTo(target);
            return {outcome: "continue"};
        } else if(rc == ERR_INVALID_TARGET) {
            return {outcome: "didnothing"};
        } else {
            return {outcome: "done"};
        }
    },
    travel_to_room : function(task, creep) {
        var destination_room = task.destination_room;
        var current_room = creep.room.roomName;
        if(!destination_room || current_room == destination_room)
            return {outcome: "didnothing"};
        if(!task.route) {
            rc = Game.map.findRoute(current_room, destination_room);
            if(rc == ERR_NO_PATH) {
                creep.say("ttr!pa");
                return {outcome: "continue"};
            }
            task.route = rc;
            task.route_index = 0;
        }
        var route = task.route;
        var element = route[task.route_index];
    },
    taskless : function(task, creep) {
        // TODO should rendevous with nearest spawn and have them assign
        var can_work = creep.body_part_count(WORK);
        var can_carry = creep.body_part_count(CARRY);
        var purpose;
        if(!can_work && !can_carry) {
            purpose = "role.dumbscout";
        } else if(can_work && !can_carry) {
            purpose = "role.cow";
        } else if(!can_work && can_carry) {
            purpose = "role.supplier";
        } else {
            purpose = _.sample(["role.supplier","role.cow","role.upgrader",
                "role.builder"]);
        }
        return {outcome: "replace", task: {type: purpose}};
    },
    deposit : function(task, creep) {
        // A high level task; the creep is carrying resources, and
        // wants to deposit them in the nearest friendly storage structure.
        // For now, we'll put them in the Storage of the creep's Spawn.
        if(_.sum(creep.carry) == 0)
            return {outcome: "didnothing"};
        var our_spawn = Game.spawns[creep.support];
        if(our_spawn) {
            var our_storage = our_spawn.room.storage;
            if(our_storage && (our_storage.is_full() == false)) {
                var task = {type: "transfer_to", target_id: our_storage.id};
                return {type: "newtask", task: task};
            }
        }
    }
}
module.exports = {
    task_functions: task_functions,
    register: function(name, func) {
        task_functions[name] = func;
    },
    run_task_queue: function(owner, tq) {
        while(tq && tq.length) {
            var task = tq[0];
            if(typeof task.times_run == 'undefined') {
                task.times_run = 0
            }
            var ttype = task.type;
            var func = task_functions[ttype];
            if(!func) {
                console.log("Task not found: " + ttype);
                return;
            }

            var t1 = cpu_tracker.start("tasks", ttype);
            try {
                var result = func(task, owner);
            } catch(err) {
                console.log("Task " + ttype + " error:" + err);
                owner.pop_task();
                continue;
            }

            cpu_tracker.stop(t1);

            if(!result) {
                console.log("Task did not return result: " + ttype);
                owner.pop_task();
            } else if(result.outcome == "done") {
                owner.pop_task();
            } else if(result.outcome == "continue") {
                task.times_run++;
            } else if(result.outcome == "rerun") {
                task.times_run++;
                continue;
            } else if(result.outcome == "newtask") {
                task.times_run++;
                owner.add_task(result.task)
            } else if(result.outcome == "replace") {
                owner.pop_task();
                owner.add_task(result.task);
            } else if(result.outcome == "didnothing") {
                owner.pop_task();
                continue;
            } else {
                console.log("Task (" + ttype + ") returned unrecognised outcome: " + result.outcome);
                owner.pop_task();
            }
            if((task == tq[0]) && task.timeout &&
                task.times_run >= task.timeout)
                owner.pop_task();
            break;
        }
    }
}
