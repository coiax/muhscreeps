Structure.prototype.getMemory = function() {
    if(this.structureType == STRUCTURE_SPAWN) {
        if(!Memory.spawns)
            Memory.spawns = {};
        if(!Memory.spawns[this.name])
            Memory.spawns[this.name] = {};
        return Memory.spawns[this.name];
    }
    if(!Memory.structures) {
        Memory.structures = {};
    }
    var mem = Memory.structures[this.id];
    if(mem) {
        return mem;
    } else {
        Memory.structures[this.id] = {};
        return Memory.structures[this.id];
    }
}

// TODO a lot of this is the same as Creep.prototype, should be possible
// to make some sort of mixin class, right?
Structure.prototype.add_task = function(task) {
    var memory = this.getMemory();
    if(!memory.task_queue) {
        memory.task_queue = [];
    }
    memory.task_queue.unshift(task);
}

Structure.prototype.pop_task = function() {
    var memory = this.getMemory();
    if(memory.task_queue) {
        memory.task_queue.shift();
        if(memory.task_queue.length == 0) {
            delete memory.task_queue;
        }
    }
};

Structure.prototype.log = function(level, subsystem, message) {
    if(!this.memory.log) {
        this.memory.log = [];
    }
    var log_entry = {level: level, message: message, tick: Game.time,
        subsystem: subsystem};
    this.memory.log.push(log_entry);
}

Structure.prototype.warning = function(subsystem, warning_msg) {
    this.log("warning", subsystem, warning_msg);
};

Structure.prototype.error = function(subsystem, error_msg) {
    this.log("error", subsystem, error_msg);
};

Structure.prototype.maintain_cost = function() {
    var decay = 0;
    var decay_time = 0;
    switch(this.structureType) {
        case STRUCTURE_CONTAINER:
            decay = CONTAINER_DECAY;
            if(this.room.controller && this.room.controller.owner) {
                decay_time = CONTAINER_DECAY_TIME_OWNED;
            } else {
                decay_time = CONTAINER_DECAY_TIME;
            }
            break;
        case STRUCTURE_RAMPART:
            decay = RAMPART_DECAY_AMOUNT;
            decay_time = RAMPART_DECAY_TIME;
            break;
        case STRUCTURE_ROAD:
            decay = ROAD_DECAY_AMOUNT;
            if(this.pos.is_swamp()) {
                decay *= CONSTRUCTION_COST_ROAD_SWAMP_RATIO;
            }
            decay_time = ROAD_DECAY_TIME;
            break;
    };
    if((decay == 0) || (decay_time == 0)) {
        return 0;
    }
    var hits_per_tick = decay / decay_time;
    var cost = hits_per_tick * REPAIR_COST;
    return cost;
};

Structure.prototype.is_type = function(stypes) {
    if(stypes.constructor != Array) {
        stypes = [stypes];
    }
    return _.includes(stypes, this.structureType);
};

Structure.prototype.is_full = function() {
    if(!this.isActive())
        return null;
    if(this.store) {
        var total = _.sum(this.store);
        return total == this.storeCapacity;
    } else {
        if(typeof this.energy == 'undefined')
            return null;
        if(typeof this.energyCapacity == 'undefined')
            return null;
        return this.energy == this.energyCapacity;
    }
};
