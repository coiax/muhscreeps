var util = require('util');
var task_manager = require('task_manager');
var outcomes = task_manager.globals.outcomes;


function generate_default_parts() {
    var counter = 1;
    while(true) {
        var parts = [];
        for (var i = 0; i < counter; i++) {
            parts.push(WORK);
        }
        for (var i = 0; i < counter; i++) {
            parts.push(CARRY);
        }
        for (var i = 0; i < counter; i++) {
            parts.push(MOVE);
        }
        if(parts.length <= 50) {
            default_parts.push(parts);
            counter++;
            continue;
        } else {
            break;
        }
    }
}
var default_parts = [];
generate_default_parts();

function build_creep(spawn, task_obj, initial_task) {
    var possible_parts;
    var role_module;
    task_obj["currently_attempting"] = initial_task;
    try {
        role_module = require(initial_task);
    } catch(err) {
        console.log("Error importing task '" + initial_task + "': " + err);
        // just eat it.
    }
    possible_parts = default_parts;
    if(role_module && role_module.parts) {
        possible_parts = role_module.parts;
    }

    var capacity = spawn.room.energyAvailable;

    var selected_parts;
    for(var i in possible_parts) {
        var partlist = possible_parts[i];
        var cost = util.body_cost(partlist);
        if(cost <= capacity) {
            selected_parts = partlist;
        } else {
            break;
        }
    }
    if(!selected_parts) {
        return;
    }
    var creep_name = initial_task.replace(".","_") + task_obj.creep_id;
    while(true) {
        var rc = spawn.canCreateCreep(selected_parts, creep_name);
        if(rc == OK) {
            task_obj.currently_spawning = initial_task;
            break;
        } else if(rc == ERR_NAME_EXISTS) {
            task_obj.creep_id++;
            continue;
        } else {
            return;
        }
    }
    task_obj.creep_id++;
    var creep_memory = {
        task_queue: [{type: initial_task}]
    }
    spawn.createCreep(selected_parts, creep_name, creep_memory);
    if(!spawn.memory.supported_creeps)
        spawn.memory.supported_creeps = [];
    spawn.memory.supported_creeps.push(creep_name);
}

function setup(task, spawn) {
    if (typeof task.creep_id == 'undefined') {
        task.creep_id = 1
    }
    task.currently_attempting = null;
    if(!spawn.spawning) {
        task.currently_spawning = null;
    }
}

var default_required = [
    {task: "role.supplier", amount: 1},
    {task: "role.cow", amount: 1},
    {task: "role.upgrader", amount: 1},
    {task: "role.builder", amount: 1},
    {task: "role.cow", amount: 2},
    {task: "role.supplier", amount: 2},
    {task: "role.cow", amount: 3},
    {task: "role.supplier", amount: 3},
    {task: "role.cow", amount: 4},
    {task: "role.supplier", amount: 4},
    {task: "role.upgrader", amount: 3},
    {task: "role.builder", amount: 4},
    {task: "role.dumbscout", amount: 10},
    {task: "role.claimer", amount: 1}
];

module.exports = {
    name : "structure.spawner",
    run : function(task, spawn) {
        setup(task, spawn);
        spawn.check_creeps();
        var counts = {};
        var supported_creeps = spawn.memory.supported_creeps || [];

        if(!task.required)
            task.required = _.cloneDeep(default_required);

        for(var i in task.required) {
            var entry = task.required[i];
            if(typeof counts[entry.task] == 'undefined') {
                counts[entry.task] = 0;
                supported_creeps.forEach(function(creep_name) {
                    var creep = Game.creeps[creep_name];
                    if(creep.has_task_in_queue(entry.task))
                        counts[entry.task]++;
                });
            }
            if(counts[entry.task] < entry.amount) {
                build_creep(spawn, task, entry.task);
                break;
            }
        }

        return new outcomes.InProgress();
    }
}

task_manager.register(module.exports.name, module.exports.run)
