var util = require('util');


function generate_default_parts() {
    counter = 1;
    while(true) {
        var parts = [];
        for (var i = 0; i < counter; i++) {
            parts.push(WORK);
        }
        for (var i = 0; i < counter; i++) {
            parts.push(CARRY);
        }
        for (var i = 0; i < counter; i++) {
            parts.push(MOVE);
        }
        if(parts.length <= 50) {
            default_parts.push(parts);
            counter++;
            continue;
        } else {
            break;
        }
    }
}
var default_parts = [];
generate_default_parts();

function build_creep(spawn, task_obj, initial_task) {
    var possible_parts;
    var role_module;
    task_obj["currently_attempting"] = initial_task;
    try {
        role_module = require(initial_task);
    } catch(err) {
        console.log("Error importing task '" + initial_task + "': " + err);
        // just eat it.
    }
    possible_parts = default_parts;
    if(role_module && role_module.parts) {
        possible_parts = role_module.parts;
    }

    var capacity = spawn.room.energyAvailable;

    var selected_parts;
    for(var i in possible_parts) {
        var partlist = possible_parts[i];
        var cost = util.body_cost(partlist);
        if(cost <= capacity) {
            selected_parts = partlist;
        } else {
            break;
        }
    }
    if(!selected_parts) {
        return;
    }
    var creep_name = initial_task.replace(".","_") + task_obj.creep_id;
    while(true) {
        var rc = spawn.canCreateCreep(selected_parts, creep_name);
        if(rc == OK) {
            task_obj.currently_spawning = initial_task;
            break;
        } else if(rc == ERR_NAME_EXISTS) {
            task_obj.creep_id++;
            continue;
        } else {
            return;
        }
    }
    task_obj.creep_id++;
    var creep_memory = {
        task_queue: [{type: initial_task}],
        support: spawn.name
    }
    spawn.createCreep(selected_parts, creep_name, creep_memory);
    var mem = spawn.memory;
    if(!mem.supported_creeps)
        mem.supported_creeps = [];
    mem.supported_creeps.push(creep_name);
}

function setup(task, spawner) {
    if(!spawner.memory.supported_creeps) {
        spawner.memory.supported_creeps = []
    }
    if (typeof task.creep_id == 'undefined') {
        task.creep_id = 1
    }
    task.currently_attempting = null;
    if(!spawner.spawning) {
        task.currently_spawning = null;
    }
}

module.exports = {
    name : "structure.spawner",
    run : function(task, spawner) {
        setup(task, spawner);
        counts = {};
        required = [
            {task: "role.supplier", amount: 1},
            {task: "role.cow", amount: 1},
            {task: "role.upgrader", amount: 1},
            {task: "role.builder", amount: 1},
            {task: "role.cow", amount: 2},
            {task: "role.supplier", amount: 2},
            {task: "role.cow", amount: 3},
            {task: "role.supplier", amount: 3},
            {task: "role.cow", amount: 4},
            {task: "role.supplier", amount: 4},
            {task: "role.upgrader", amount: 3},
            {task: "role.builder", amount: 4},
            {task: "role.dumbscout", amount: 10},
            {task: "role.guard", amount: 3},
            {task: "role.claimer", amount: 1}
        ];

        for(var i in required) {
            var entry = required[i];
            if(!counts[entry.task]) {
                var creeps = util.get_creeps_with_task(entry.task);
                counts[entry.task] = creeps.length;
            }
            if(counts[entry.task] < entry.amount) {
                build_creep(spawner, task, entry.task);
                break;
            }
        }

        return {outcome: "continue"};
    }
}

require('task_manager').register(module.exports.name, module.exports.run)
