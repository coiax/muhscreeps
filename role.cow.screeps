var util = require('util');
var task_manager = require('task_manager');

var roleCow = {
    name: "role.cow",
    parts: [
        [WORK, CARRY, MOVE],
        [WORK, WORK, CARRY, MOVE],
        [WORK, WORK, WORK, CARRY, MOVE, MOVE]
        //[WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE],
        //[WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE],
        //[WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]
    ],
    run: function(task, creep) {
        var source = Game.getObjectById(task.source_id);
        if(!source) {
            creep.say("Mooo!");
            var sources = creep.room.find(FIND_SOURCES);
            var cow_strength = {};
            sources.forEach(function(s) {
                cow_strength[s] = 0;
            });
            for(var name in Game.creeps) {
                var other = Game.creeps[name];
                if(creep.name == other.name) {
                    continue;
                }
                var other_task = other.has_task_in_queue(module.exports.name)
                if(!other_task) {
                    continue;
                }
                var other_source = Game.getObjectById(other_task.source_id);
                cow_strength[other_source] += other.body_part_count(WORK);
            };
            sources = _.sortBy(sources, function(s) {
                return cow_strength[s];
            });
            if(sources.length) {
                source = sources[0];
                task.source_id = source.id;
            }
        }
        if(!source) {
            creep.say("Moo...");
            return {outcome: "continue"};
        }

        var pasture = util.memoryPosition(task.pasture_loc);
        if(pasture && pasture.getRangeTo(source) != 1) {
            creep.say("Moo?");
            task.pasture_loc = null;
            pasture = null;
        }

        if(!pasture) {
            var potential_pasture = source.pos.walkable_adjacent();
            pasture = _.sample(potential_pasture);
            task.pasture_loc = pasture;
        }
        if(!pasture) {
            creep.say("...moo");
            task.pasture_loc = null;
            task.source_id = null;
            return {outcome: "continue"};
        }

        if(!pasture.isEqualTo(creep.pos)) {
            if(pasture.isNearTo(creep)) {
                var other_creeps = pasture.lookFor(FIND_CREEPS)
                if(other_creeps && other_creeps.length) {
                    other_creeps.forEach(function(other) {
                        if(!other.has_task_in_queue(module.exports.name)) {
                            // maybe you should move your fat ass out of the way
                            // because I'm the next drag super star.
                            creep.say("Mooove");
                            other.add_task({type: "leave", pos: pasture});
                        } else {
                            // this location has been taken by another cow.
                            task.source_id = null;
                            task.pasture_loc = null;
                        }
                    });
                }
                if(!task.pasture_loc)
                    return {outcome: "continue"};
            }
            creep.moveTo(pasture);
            return {outcome: "continue"};
        }

        var container = Game.getObjectById(task.output_container_id);
        if(!container) {
            // Then scan for a container to move stuff into
            var containers = creep.pos.findInRange(FIND_STRUCTURES, 1,
                {filter : function(structure) {
                    return structure.structureType == STRUCTURE_CONTAINER;
            }});
            if(containers.length) {
                container = containers[0];
                task.output_container_id = container.id;
            }
        }

        // If not present, then place the construction site and then
        // build it
        if(!container) {
            var sites = creep.pos.findInRange(FIND_CONSTRUCTION_SITES, 1,
                filter = function(site) {
                    return site.structureType == STRUCTURE_CONTAINER;
            });
            var site;
            if(sites.length) {
                site = sites[0];
            } else {
                var opposite_dir = source.pos.getDirectionTo(creep);
                var site_pos = creep.pos.step(opposite_dir);
                var rc = site_pos.createConstructionSite(STRUCTURE_CONTAINER);
                // It will be found next work tick.
                return {outcome: "continue"};
            }
            creep.add_task({type: "construct",
                target_id: site.id, resupply:"harvest"});
            return {outcome: "continue"};
        }
        if(container && (container.pos.getRangeTo(creep) <= 1)) {
            task.output_container_id = null;
            return {outcome: "continue"};
        }
        // Then spend the rest of our lifespan harvesting and moving that
        // into the container, repairing the container first if needed.
        // The priority system SHOULD just make this all happen.
        var rc = creep.harvest(source);
        if(rc == OK) {
            creep.memory.no_driveby_repair = true;
        } else if(rc == ERR_NOT_ENOUGH_RESOURCES) {
            creep.memory.no_driveby_repair = false;
        }
        // if for some reason the container isn't repaired by others
        // and it drops to half health, then fix it up, but the cow should
        // focus on just harvesting as much as possible
        if(container.hits < container.hitsMax) {
            creep.repair(container);
        } else {
            creep.transfer(container, RESOURCE_ENERGY);
        }
        return {outcome: "continue"};
    }
};
task_manager.register(roleCow.name, roleCow.run);
module.exports = roleCow;
