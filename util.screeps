function needs_energy(st) {
    if(!st.isActive())
        return false;
    if(typeof st.energy == 'undefined')
        return false;
    if(typeof st.energyCapacity == 'undefined')
        return false;
    return st.energy < st.energyCapacity;
};

function is_damaged(obj) {
    if(typeof obj.hits == 'undefined')
        return false;
    if(typeof obj.hitsMax == 'undefined')
        return false;
    return obj.hits < obj.hitsMax;
};

function cpulog(msg) {
    console.log(Game.cpu.getUsed() + " " + msg);
};

function mean(arr) {
    var sum = 0;
    arr.forEach(function(num) {
        sum += num;
    });
    return sum / arr.length;
}

function standard_deviation(arr) {
    var avg = mean(arr);
    var sum = 0;
    arr.forEach(function(num) {
        sum += Math.pow(num - avg, 2);
    });
    sum /= arr.length;
    return Math.pow(sum, 0.5);
}

function room_walk(roomname, func, maximum_depth) {
    if(!maximum_depth)
        maximum_depth = 10;
    // given a roomname, walk along the map, running func on each room
    // encountered, returning the first roomname that func returns
    // true for.
    var depth = 0;
    var visited_rooms = new Set();
    var room_list = [roomname];
    var matching_rooms = [];
    var next_list = [];
    while((matching_rooms.length == 0) && (depth < maximum_depth)) {
        console.log(depth + ": " + JSON.stringify(room_list));
        room_list.forEach(function(rn) {
            visited_room = visited_rooms.add(rn);
            if(func(rn)) {
                matching_rooms.push(rn);
            } else {
                exits = Game.map.describeExits(rn);
                for(var dir in exits) {
                    var other_rn = exits[dir];
                    if(!visited_rooms.has(other_rn)) {
                        next_list.push(other_rn);
                    }
                }
            }
        });
        depth++;
        room_list = next_list;
    }
    return matching_rooms;
}

module.exports = {
    room_walk: room_walk,
    opposite_dir: function(dir) {
        var num = dir + 4;
        if(num > 8)
            num = num - 8;
        return num;
    },
    body_cost: function(body) {
        var sum = 0;
        body.forEach(function(part) {
            sum += BODYPART_COST[part];
        });
        return sum;
    },

    needs_energy: needs_energy,
    is_damaged: is_damaged,
    cpulog: cpulog,
    mean: mean,
    standard_deviation: standard_deviation,
    memoryPosition: function(obj) {
        if(obj) {
            return new RoomPosition(obj.x, obj.y, obj.roomName);
        } else {
            return null;
        }
    },
    get_creeps_with_task: function(ttype) {
        var taskers = [];
        for(var name in Game.creeps) {
            var creep = Game.creeps[name];
            if(creep.has_task_in_queue(ttype)) {
                taskers.push(creep);
            }
        }
        return taskers;
    }
}
