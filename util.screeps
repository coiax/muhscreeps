RoomPosition.prototype.find = function() {
    var room = Game.rooms[this.roomName];
    return room.find.apply(room, arguments);
};

RoomPosition.prototype.findStructures = function(stypes) {
    if(stypes) {
        if(stypes.constructor != Array) {
            stypes = [stypes];
        }
        filter = function(st) {
            return _.includes(stypes, st.structureType);
        }
        return this.find(FIND_STRUCTURES, {filter: filter});
    } else {
        return this.find(FIND_STRUCTURES);
    }
};

RoomPosition.prototype.findDamagedStructures = function(stypes) {
    return _.filter(this.findStructures(stypes), is_damaged);
};

RoomPosition.prototype.findNeedingEnergyStructures = function(stypes) {
    return _.filter(this.findStructures(stypes), needs_energy);
};
RoomPosition.prototype.findDamagedFriendlyCreeps = function() {
    return this.find(FIND_MY_CREEPS, {filter: is_damaged});
};

function needs_energy(st) {
    if(!st.isActive())
        return false;
    if(typeof st.energy == 'undefined')
        return false;
    if(typeof st.energyCapacity == 'undefined')
        return false;
    return st.energy < st.energyCapacity;
};

function is_damaged(obj) {
    if(typeof obj.hits == 'undefined')
        return false;
    if(typeof obj.hitsMax == 'undefined')
        return false;
    return obj.hits < obj.hitsMax;
};

function cpulog(msg) {
    console.log(Game.cpu.getUsed() + " " + msg);
};

module.exports = {
    opposite_dir: function(dir) {
        var num = dir + 4;
        if(num > 8)
            num = num - 8;
        return num;
    },
    body_cost: function(body) {
        var sum = 0;
        body.forEach(function(part) {
            sum += BODYPART_COST[part];
        });
        return sum;
    },

    needs_energy: needs_energy,
    is_damaged: is_damaged,
    cpulog: cpulog
}
