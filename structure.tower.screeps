var util = require('util');
var task_manager = require('task_manager');
var outcomes = task_manager.globals.outcomes;

function efficient_tower_repair(tower, st) {
    var dmg_taken = st.hitsMax - st.hits;
    if(!dmg_taken)
        return false;
    var dist = tower.pos.getRangeTo(st);
    var repair_amount = tower.expected_power("repair", dist);
    return dmg_taken >= repair_amount;
}

module.exports = {
    name: "structure.tower",
    run : function(task, tower) {
        if(tower.energy < TOWER_ENERGY_COST) {
            return new outcomes.InProgress();
        }
        var target;
        var mode;
        // 1) attack enemy creeps
        if(!target) {
            target = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
            mode = "attack";
        }
        // 2) heal friendly creeps
        if(!target) {
            var hurt_friendlies = tower.pos.findDamagedFriendlyCreeps();
            target = tower.pos.findClosestByRange(hurt_friendlies);
            mode = "heal";
        }
        // 3) repair our structures, except ramparts
        if(!target) {
            var target = tower.pos.findClosestByRange(
                FIND_MY_STRUCTURES, {filter:
                function(st) {
                    if(st.structureType == STRUCTURE_RAMPART)
                        return false;
                    return st.is_damaged();
                }});
            mode = "repair";
        }
        // then repair the containers, roads,
        // (and walls+ramparts if enabled
        if(!target) {
            var order = [STRUCTURE_CONTAINER, STRUCTURE_ROAD];
            if(task.wall_repair) {
                // wall and rampart being in an [] is deliberate, this means
                // they'll be treated the same priority.
                order.push([STRUCTURE_WALL, STRUCTURE_RAMPART]);
            }
            for(var i in order) {
                var stypes = order[i]; {
                    var damaged = tower.room.find(FIND_STRUCTURES, {filter:
                        function(st) {
                            return _.includes(stypes, st.structureType) &&
                                st.is_damaged();
                    }});
                    damaged = _.sortBy(damaged, _.property("hits"));
                    if(damaged.length) {
                        target = damaged[0];
                        mode = "repair";
                        break;
                    }
                }
            }
        }
        if(target) {
            var new_task = {type: "tower_target", target_id: target.id,
                mode: mode, timeout: 25};
            return new outcomes.PushTask(new_task);
        } else {
            return new outcomes.InProgress();
        }
    }
}
task_manager.register(module.exports.name, module.exports.run);
